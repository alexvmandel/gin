// End the current hand
            endHand(message) {
                this.isHandOver = true;
                this.updateGameStatus(message);
                
                // Record the winner of this hand for dealer assignment in next hand
                if (message.includes("You win")) {
                    this.lastHandWinner = 'player';
                } else if (message.includes("Opponent wins")) {
                    this.lastHandWinner = 'opponent';
                }
                
                // Display game end dialog
                const gameEndDialog = document.getElementById('gameEndDialog');
                const gameEndTitle = document.getElementById('gameEndTitle');
                const gameEndContent = document.getElementById('gameEndContent');
                
                gameEndTitle.textContent = 'Hand Complete';
                
                // Create content for the dialog
                gameEndContent.innerHTML = '';
                
                const resultMessage = document.createElement('p');
                resultMessage.textContent = message;
                resultMessage.style.marginBottom = '15px';
                resultMessage.style.fontWeight = 'bold';
                gameEndContent.appendChild(resultMessage);
                
                // Add score information
                const scoreInfo = document.createElement('div');
                
                const playerScoreInfo = document.createElement('p');
                playerScoreInfo.textContent = `Your Score: ${this.player.score} points, ${this.player.cocottes} cocottes`;
                scoreInfo.appendChild(playerScoreInfo);
                
                const opponentScoreInfo = document.createElement('p');
                opponentScoreInfo.textContent = `Opponent's Score: ${this.opponent.score} points, ${this.opponent.cocottes} cocottes`;
                scoreInfo.appendChild(opponentScoreInfo);
                
                // Add dealer information for next hand
                const dealerInfo = document.createElement('p');
                dealerInfo.style.marginTop = '10px';
                dealerInfo.style.fontStyle = 'italic';
                
                if (this.lastHandWinner === 'player') {
                    dealerInfo.textContent = "You'll be the dealer in the next hand.";
                } else {
                    dealerInfo.textContent = "Opponent will be the dealer in the next hand.";
                }
                
                scoreInfo.appendChild(dealerInfo);
                gameEndContent.appendChild(scoreInfo);
                
                // Update the scorecard
                updateScoreCard();
                
                // Show the dialog
                gameEndDialog.style.display = 'flex';
            }
        }

        // Initialize the game when the page is loaded
        document.addEventListener('DOMContentLoaded', function() {
            console.log("DOM Loaded - Starting game");
            const game = new MandelGinGame();
        });
    </script>
</body>
</html>            // Calculate score for Grand Gin
            calculateGrandGinScore(playerWins) {
                const winner = playerWins ? this.player : this.opponent;
                const loser = playerWins ? this.opponent : this.player;
                
                // Calculate unmatched cards value for the loser
                const loserUnmatchedValue = loser.getUnmatchedCardsValue();
                
                // Calculate points
                let points = 50 + loserUnmatchedValue;
                let cocottes = 5;
                
                // Apply double scoring if applicable
                if (this.isDoubleScoring) {
                    points *= 2;
                    cocottes = 9;
                }
                
                // Update scores
                winner.score += points;
                winner.cocottes += cocottes;
                
                // Update column scores
                if (playerWins) {
                    this.player.column1Points += points;
                    this.player.column1Cocottes += cocottes;
                } else {
                    this.opponent.column1Points += points;
                    this.opponent.column1Cocottes += cocottes;
                }
                
                // Update score display
                this.updateScoreDisplay();
                
                return { points, cocottes };
            }

            // Calculate score for Gin
            calculateGinScore(playerWins) {
                const winner = playerWins ? this.player : this.opponent;
                const loser = playerWins ? this.opponent : this.player;
                
                // Calculate unmatched cards value for the loser
                const loserUnmatchedValue = loser.getUnmatchedCardsValue();
                
                // Calculate points
                let points = 25 + loserUnmatchedValue;
                let cocottes = 3;
                
                // Apply double scoring if applicable
                if (this.isDoubleScoring) {
                    points *= 2;
                    cocottes = 5;
                }
                
                // Update scores
                winner.score += points;
                winner.cocottes += cocottes;
                
                // Update column scores
                if (playerWins) {
                    this.player.column1Points += points;
                    this.player.column1Cocottes += cocottes;
                } else {
                    this.opponent.column1Points += points;
                    this.opponent.column1Cocottes += cocottes;
                }
                
                // Update score display
                this.updateScoreDisplay();
                
                return { points, cocottes };
            }

            // Calculate score for Go Down
            calculateGoDownScore(playerWins, goDownValue, loserUnmatchedValue) {
                const winner = playerWins ? this.player : this.opponent;
                const loser = playerWins ? this.opponent : this.player;
                
                // VALIDATE: Make sure Go Down value is valid
                const descentValue = this.getDescentValue();
                if (goDownValue > descentValue) {
                    this.debug("ERROR: Invalid Go Down scoring - value exceeds Descent card value", 
                        {goDownValue, descentValue});
                    return;
                }
                
                // Calculate points
                let points = loserUnmatchedValue - goDownValue;
                const cocottes = 1;
                
                // Apply double scoring if applicable
                if (this.isDoubleScoring) {
                    points *= 2;
                }
                
                // Update scores
                winner.score += points;
                winner.cocottes += cocottes;
                
                // Update column scores
                if (playerWins) {
                    this.player.column1Points += points;
                    this.player.column1Cocottes += cocottes;
                } else {
                    this.opponent.column1Points += points;
                    this.opponent.column1Cocottes += cocottes;
                }
                
                // Update score display
                this.updateScoreDisplay();
                
                this.debug("Go Down scoring:", {
                    playerWins,
                    goDownValue,
                    loserUnmatchedValue,
                    points,
                    cocottes,
                    isDoubleScoring: this.isDoubleScoring
                });
                
                return { points, cocottes };
            }

            // Calculate score for Go Bust
            calculateGoBustScore(playerWins, goDownValue, winnerUnmatchedValue) {
                const winner = playerWins ? this.player : this.opponent;
                
                // Calculate points
                let points = 50 + (goDownValue - winnerUnmatchedValue);
                const cocottes = 1;
                
                // Apply double scoring if applicable
                if (this.isDoubleScoring) {
                    points *= 2;
                }
                
                // Update scores
                winner.score += points;
                winner.cocottes += cocottes;
                
                // Update column scores
                if (playerWins) {
                    this.player.column1Points += points;
                    this.player.column1Cocottes += cocottes;
                } else {
                    this.opponent.column1Points += points;
                    this.opponent.column1Cocottes += cocottes;
                }
                
                // Update score display
                this.updateScoreDisplay();
                
                this.debug("Go Bust scoring:", {
                    playerWins,
                    goDownValue,
                    winnerUnmatchedValue,
                    points,
                    cocottes,
                    isDoubleScoring: this.isDoubleScoring
                });
                
                return { points, cocottes };
            }            // Update score display
            updateScoreDisplay() {
                // Update the simple score tracking
                // (Keep this for internal state tracking)
                this.player.column1Points = this.player.score;
                this.player.column1Cocottes = this.player.cocottes;
                this.opponent.column1Points = this.opponent.score;
                this.opponent.column1Cocottes = this.opponent.cocottes;
                
                // Update the detail displayed in menu scorecard
                updateScoreCard();
            }<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mandel Gin</title>
    <style>
        :root {
            --baize-color: #076324;
            --baize-darker: #054d1b;
            --gold-color: #d4af37;
            --card-bg: #fff;
            --text-color: #fff;
            --highlight-color: #f8d775;
            --button-color: #2c7873;
            --button-hover: #3aafa9;
            --button-text: #fff;
            --error-color: #ff6b6b;
            --success-color: #6bff6b;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
        }

        body {
            background-color: var(--baize-color);
            color: var(--text-color);
            min-height: 100vh;
            padding: 10px;
            background-image: radial-gradient(var(--baize-darker) 15%, transparent 15%);
            background-size: 10px 10px;
        }

        .game-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 10px;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--gold-color);
            padding-bottom: 10px;
        }

        h1 {
            font-family: 'Georgia', serif;
            font-size: 2.5rem;
            color: var(--gold-color);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .game-status {
            background-color: rgba(0, 0, 0, 0.4);
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 20px;
            font-size: 1.2rem;
            text-align: center;
        }

        .game-status.highlight {
            background-color: var(--highlight-color);
            color: #000;
            font-weight: bold;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }

        .game-board {
            display: grid;
            grid-template-areas:
                "opponent opponent"
                "deck discard"
                "player player"
                "controls controls";
            gap: 20px;
        }

        @media (min-width: 768px) {
            .game-board {
                grid-template-areas:
                    "opponent opponent opponent"
                    "deck discard controls"
                    "player player player";
                grid-template-columns: 1fr 1fr 2fr;
            }
        }

        .opponent-area {
            grid-area: opponent;
            min-height: 150px;
            border-radius: 10px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .player-area {
            grid-area: player;
            min-height: 180px;
            border-radius: 10px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .deck-area {
            grid-area: deck;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .discard-area {
            grid-area: discard;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .controls-area {
            grid-area: controls;
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }

        .hand {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
            min-height: 100px;
            width: 100%;
        }

        .card-placeholder {
            width: 60px;
            height: 90px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            border: 1px dashed rgba(255, 255, 255, 0.3);
        }

        @media (min-width: 768px) {
            .card-placeholder {
                width: 80px;
                height: 112px;
            }
        }

        .card {
            width: 60px;
            height: 90px;
            background-color: var(--card-bg);
            border-radius: 5px;
            position: relative;
            box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            user-select: none;
            transition: transform 0.2s ease;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 5px;
            font-weight: bold;
        }

        @media (min-width: 768px) {
            .card {
                width: 80px;
                height: 112px;
            }
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 2px 5px 10px rgba(0, 0, 0, 0.4);
        }

        .card.selected {
            box-shadow: 0 0 0 3px var(--highlight-color);
        }

        .card.facedown {
            background-color: #7b5d94;
            background-image: repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(0, 0, 0, 0.1) 10px, rgba(0, 0, 0, 0.1) 20px);
        }

        .card-top, .card-bottom {
            display: flex;
            justify-content: center;
            font-size: 16px;
        }

        .card-center {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-grow: 1;
            font-size: 24px;
        }

        .card.hearts, .card.diamonds {
            color: #e44145;
        }

        .card.clubs, .card.spades {
            color: #333;
        }

        .deck, .discard {
            position: relative;
            width: 80px;
            height: 112px;
            border-radius: 5px;
            background-color: var(--card-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        }

        .deck {
            background-color: #7b5d94;
            background-image: repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(0, 0, 0, 0.1) 10px, rgba(0, 0, 0, 0.1) 20px);
        }

        .deck:hover, .discard:hover {
            transform: scale(1.05);
            box-shadow: 2px 5px 10px rgba(0, 0, 0, 0.4);
        }

        .deck.disabled, .discard.disabled {
            cursor: not-allowed;
            opacity: 0.7;
        }

        .deck.disabled:hover, .discard.disabled:hover {
            transform: none;
            box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        }

        .deck-count, .discard-count {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            position: absolute;
            top: -10px;
            right: -10px;
        }

        .deck::after {
            content: '';
            position: absolute;
            width: 80px;
            height: 112px;
            background-color: #7b5d94;
            border-radius: 5px;
            z-index: -1;
            top: 2px;
            left: 2px;
        }

        .discard::after {
            content: '';
            position: absolute;
            width: 80px;
            height: 112px;
            background-color: var(--card-bg);
            border-radius: 5px;
            z-index: -1;
            top: 2px;
            left: 2px;
        }

        .descent-card {
            margin-top: 20px;
            border: 2px solid var(--gold-color);
        }

        .descent-value {
            margin-top: 5px;
            font-size: 0.9rem;
            color: var(--gold-color);
        }

        button {
            background-color: var(--button-color);
            color: var(--button-text);
            border: none;
            border-radius: 5px;
            padding: 10px 15px;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
            box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            background-color: var(--button-hover);
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .sets-display {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
            justify-content: center;
        }

        .set {
            display: flex;
            gap: 2px;
            background-color: rgba(0, 0, 0, 0.2);
            padding: 5px;
            border-radius: 5px;
        }

        .unmatched-cards {
            display: flex;
            gap: 5px;
            margin-top: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .action-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
        }

        .hand-title {
            align-self: flex-start;
            margin-bottom: 5px;
            color: var(--gold-color);
            font-weight: bold;
        }

        .dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .dialog {
            background-color: var(--baize-color);
            border: 3px solid var(--gold-color);
            border-radius: 10px;
            padding: 20px;
            max-width: 90%;
            width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
        }

        .dialog h2 {
            color: var(--gold-color);
            margin-bottom: 15px;
            text-align: center;
            font-family: 'Georgia', serif;
        }

        .dialog-content {
            margin-bottom: 20px;
        }

        .dialog-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .rules {
            cursor: pointer;
            color: var(--gold-color);
            text-decoration: underline;
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 0.9rem;
        }

        .menu-button {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: transparent;
            color: var(--gold-color);
            box-shadow: none;
            font-size: 1.2rem;
            padding: 5px 10px;
        }

        /* Animation for card dealing */
        @keyframes dealCard {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
            }
            100% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
        }

        .dealing {
            animation: dealCard 0.3s ease-out;
        }

        /* Score display animation */
        @keyframes scoreReveal {
            0% {
                transform: scale(0.8);
                opacity: 0;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .score-reveal {
            animation: scoreReveal 0.5s ease-out;
        }

        /* Highlight for valid sets */
        .valid-set {
            box-shadow: 0 0 10px var(--success-color);
        }

        /* Sets management styles */
        .sets-manager {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
            margin-top: 15px;
        }

        .sets-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
            justify-content: center;
        }

        .sets-selector-title {
            width: 100%;
            font-weight: bold;
            color: var(--gold-color);
            margin-bottom: 5px;
            text-align: center;
        }

        .no-select {
            user-select: none;
        }

        .how-to-play {
            margin-top: 20px;
            font-size: 0.9rem;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }

        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }

        .tooltip .tooltip-text {
            visibility: hidden;
            width: 200px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            text-align: center;
            border-radius: 5px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        /* Scorecard styles */
        .scorecard-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            margin-bottom: 15px;
        }

        .scorecard-table th, .scorecard-table td {
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px;
            text-align: center;
        }

        .scorecard-table th {
            background-color: rgba(0, 0, 0, 0.3);
        }

        .player1-column {
            background-color: rgba(255, 255, 200, 0.15);
        }

        .player2-column {
            background-color: rgba(200, 220, 255, 0.15);
        }

        .player-header {
            font-weight: bold;
            font-size: 1.1em;
        }

        .column-header {
            font-weight: normal;
        }

        .score-crossed-out {
            text-decoration: line-through;
            opacity: 0.7;
        }

        .score-cell {
            min-height: 60px;
        }

        .score-current {
            font-weight: bold;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 500px) {
            h1 {
                font-size: 1.8rem;
            }
            
            .card {
                width: 50px;
                height: 75px;
                font-size: 12px;
            }
            
            .deck, .discard {
                width: 70px;
                height: 98px;
            }
            
            .deck::after, .discard::after {
                width: 70px;
                height: 98px;
            }
            
            .card-top, .card-bottom {
                font-size: 14px;
            }
            
            .card-center {
                font-size: 20px;
            }
            
            .hand {
                gap: 3px;
            }

            .card-placeholder {
                width: 50px;
                height: 75px;
            }

            .game-status {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <button id="menuButton" class="menu-button">≡</button>
        <span id="rulesButton" class="rules">Rules</span>
        
        <header>
            <h1>Mandel Gin</h1>
        </header>

        <div id="gameStatus" class="game-status">Welcome to Mandel Gin</div>

        <div class="game-board">
            <div class="opponent-area">
                <div class="hand-title">Opponent's Hand</div>
                <div id="opponentHand" class="hand"></div>
                <div id="opponentSets" class="sets-display" style="display: none;"></div>
            </div>

            <div class="deck-area">
                <div class="deck" id="deck">
                    <div class="deck-count" id="deckCount">0</div>
                </div>
                <div class="deck descent-card" id="descentCard">
                </div>
                <div class="descent-value" id="descentValue"></div>
            </div>

            <div class="discard-area">
                <div class="discard" id="discard">
                    <div class="discard-count" id="discardCount">0</div>
                </div>
            </div>

            <div class="controls-area">
                <div id="gameControls">
                    <button id="newGameButton">New Game</button>
                    <div class="action-buttons" id="actionButtons" style="display: none;">
                        <button id="goDownButton" disabled>Go Down</button>
                        <button id="ginButton" disabled>Gin</button>
                        <button id="grandGinButton" disabled>Grand Gin</button>
                    </div>
                </div>
                <div id="setsManager" class="sets-manager" style="display: none;">
                    <div class="sets-selector-title">Organize Your Sets</div>
                    <div id="availableCards" class="sets-selector"></div>
                    <div class="sets-selector">
                        <button id="createSetButton">Create Set</button>
                        <button id="clearSetButton">Clear Selection</button>
                    </div>
                    <div id="currentSets"></div>
                </div>
            </div>

            <div class="player-area">
                <div class="hand-title">Your Hand</div>
                <div id="playerHand" class="hand"></div>
                <div id="playerSets" class="sets-display" style="display: none;"></div>
                <div id="playerUnmatched" class="unmatched-cards" style="display: none;"></div>
            </div>
        </div>

        <div id="howToPlay" class="how-to-play">
            <p><strong>Quick Guide:</strong> Draw a card from the deck or discard pile on your turn. Form sets (3+ cards of same value or sequential in same suit). Discard to end your turn. Win by forming sets with all or most cards.</p>
        </div>
    </div>

    <!-- Rules Dialog -->
    <div id="rulesDialog" class="dialog-overlay" style="display: none;">
        <div class="dialog">
            <h2>Mandel Gin Rules</h2>
            <div class="dialog-content">
                <h3>Objective</h3>
                <p>Form sets and minimize the value of unmatched cards in your hand.</p>
                
                <h3>Card Values</h3>
                <p>Ace: 15 points<br>
                King, Queen, Jack: 10 points each<br>
                Number Cards: Face value (2-10 points)</p>
                
                <h3>Sets</h3>
                <p><strong>Matching Sets:</strong> 3 or 4 cards of the same value (e.g., 2♥, 2♠, 2♦)<br>
                <strong>Runs:</strong> 3 or more consecutive cards of the same suit (e.g., A♥, 2♥, 3♥, 4♥)</p>
                <p>Aces can be high or low or both. Sets have no maximum size.</p>
                
                <h3>Gameplay</h3>
                <p>1. The dealer gives 11 cards to the opponent and 10 to themselves<br>
                2. The non-dealer (with 11 cards) starts by discarding one card<br>
                3. Players take turns drawing a card from either the stock pile or discard pile<br>
                4. After drawing, discard one card (cannot discard the same card just picked from discard)<br>
                5. Try to form sets with your cards</p>
                
                <h3>Winning Conditions</h3>
                <p><strong>Grand Gin:</strong> All 11 cards in sets<br>
                <strong>Gin:</strong> 10 cards in sets, discard the unmatched card<br>
                <strong>Go Down:</strong> The total value of unmatched cards is equal to or less than the Descent card value<br>
                <strong>Go Bust:</strong> If a player "Goes Down," but their opponent has unmatched cards with a lower total</p>
                
                <h3>The Descent Card</h3>
                <p>Hearts or Spades: Hand scores double points<br>
                Clubs or Diamonds: Hand scores single points<br>
                If Ace: "Gin Obligatoire" (only Gin or Grand Gin wins possible)</p>
            </div>
            <div class="dialog-buttons">
                <button id="closeRulesButton">Close</button>
            </div>
        </div>
    </div>

    <!-- Menu Dialog -->
    <div id="menuDialog" class="dialog-overlay" style="display: none;">
        <div class="dialog">
            <h2>Menu</h2>
            <div class="dialog-content">
                <button id="newGameMenuButton" style="width: 100%; margin-bottom: 10px;">New Game</button>
                <button id="rulesMenuButton" style="width: 100%; margin-bottom: 10px;">Rules</button>
                
                <!-- Add Scorecard here -->
                <div style="margin-top: 20px; margin-bottom: 10px;">
                    <h3 style="margin-bottom: 10px; text-align: center; border-bottom: 1px solid var(--gold-color); padding-bottom: 5px;">Game Scorecard</h3>
                    <table class="scorecard-table">
                        <thead>
                            <tr>
                                <th rowspan="2"></th>
                                <th colspan="3" class="player-header player1-column">Player 1</th>
                                <th colspan="3" class="player-header player2-column">Player 2</th>
                            </tr>
                            <tr>
                                <th class="column-header player1-column">Column 1</th>
                                <th class="column-header player1-column">Column 2</th>
                                <th class="column-header player1-column">Column 3</th>
                                <th class="column-header player2-column">Column 1</th>
                                <th class="column-header player2-column">Column 2</th>
                                <th class="column-header player2-column">Column 3</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Points</strong></td>
                                <td class="player1-column" id="p1c1-points">0</td>
                                <td class="player1-column" id="p1c2-points">0</td>
                                <td class="player1-column" id="p1c3-points">0</td>
                                <td class="player2-column score-cell" id="p2c1-points">0</td>
                                <td class="player2-column score-cell" id="p2c2-points">0</td>
                                <td class="player2-column score-cell" id="p2c3-points">0</td>
                            </tr>
                            <tr>
                                <td><strong>Cocottes</strong></td>
                                <td class="player1-column" id="p1c1-cocottes">0</td>
                                <td class="player1-column" id="p1c2-cocottes">0</td>
                                <td class="player1-column" id="p1c3-cocottes">0</td>
                                <td class="player2-column score-cell" id="p2c1-cocottes">0</td>
                                <td class="player2-column score-cell" id="p2c2-cocottes">0</td>
                                <td class="player2-column score-cell" id="p2c3-cocottes">0</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="dialog-buttons">
                <button id="closeMenuButton">Close</button>
            </div>
        </div>
    </div>

    <!-- Game End Dialog -->
    <div id="gameEndDialog" class="dialog-overlay" style="display: none;">
        <div class="dialog">
            <h2 id="gameEndTitle">Hand Complete</h2>
            <div class="dialog-content" id="gameEndContent">
                <!-- Content will be dynamically inserted -->
            </div>
            <div class="dialog-buttons">
                <button id="nextHandButton">Next Hand</button>
            </div>
        </div>
    </div>

    <!-- Go Down Dialog -->
    <div id="goDownDialog" class="dialog-overlay" style="display: none;">
        <div class="dialog">
            <h2>Go Down</h2>
            <div class="dialog-content">
                <p>Select the cards you want to Go Down with:</p>
                <div id="goDownCards" class="sets-selector" style="margin-top: 15px;"></div>
                <p style="margin-top: 15px;">Total unmatched value: <span id="unmatchedValue">0</span></p>
                <p>Descent card value: <span id="descentCardValue">0</span></p>
            </div>
            <div class="dialog-buttons">
                <button id="confirmGoDownButton" disabled>Confirm Go Down</button>
                <button id="cancelGoDownButton">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Card class to represent individual cards
        class Card {
            constructor(suit, rank) {
                this.suit = suit;
                this.rank = rank;
                this.id = `${rank}${suit}`;
                this.faceUp = false;
                this.selected = false;
                this.inSet = false;
            }

            // Get the display value of the card
            get displayRank() {
                if (this.rank === '1') return 'A';
                if (this.rank === '11') return 'J';
                if (this.rank === '12') return 'Q';
                if (this.rank === '13') return 'K';
                return this.rank;
            }

            // Get the suit symbol
            get suitSymbol() {
                if (this.suit === 'S') return '♠';
                if (this.suit === 'H') return '♥';
                if (this.suit === 'D') return '♦';
                if (this.suit === 'C') return '♣';
                return this.suit;
            }

            // Get the color based on suit
            get color() {
                return (this.suit === 'H' || this.suit === 'D') ? 'red' : 'black';
            }

            // Get the numeric value for scoring
            get value() {
                if (this.rank === '1') return 15; // Ace
                if (this.rank === '11' || this.rank === '12' || this.rank === '13') return 10; // Face cards
                return parseInt(this.rank); // Number cards
            }

            // Get the numeric rank for sorting and run detection
            get numericRank() {
                return parseInt(this.rank);
            }

            // Create a card element for display
            createCardElement() {
                const cardElement = document.createElement('div');
                cardElement.className = `card ${this.suitClass}`;
                cardElement.dataset.id = this.id;
                
                if (!this.faceUp) {
                    cardElement.classList.add('facedown');
                    return cardElement;
                }
                
                // Add selection state
                if (this.selected) {
                    cardElement.classList.add('selected');
                }

                // Add suit class for styling
                if (this.suit === 'H') cardElement.classList.add('hearts');
                if (this.suit === 'D') cardElement.classList.add('diamonds');
                if (this.suit === 'C') cardElement.classList.add('clubs');
                if (this.suit === 'S') cardElement.classList.add('spades');

                // Create card structure
                const cardTop = document.createElement('div');
                cardTop.className = 'card-top';
                cardTop.textContent = `${this.displayRank}${this.suitSymbol}`;
                
                const cardCenter = document.createElement('div');
                cardCenter.className = 'card-center';
                cardCenter.textContent = this.suitSymbol;
                
                const cardBottom = document.createElement('div');
                cardBottom.className = 'card-bottom';
                cardBottom.textContent = `${this.displayRank}${this.suitSymbol}`;
                
                cardElement.appendChild(cardTop);
                cardElement.appendChild(cardCenter);
                cardElement.appendChild(cardBottom);
                
                return cardElement;
            }

            // Create a simple card for sets display
            createSimpleCardElement() {
                const cardElement = document.createElement('div');
                cardElement.className = `card ${this.suitClass} no-select`;
                cardElement.dataset.id = this.id;
                cardElement.style.transform = 'none';
                cardElement.style.cursor = 'default';
                
                // Add suit class for styling
                if (this.suit === 'H') cardElement.classList.add('hearts');
                if (this.suit === 'D') cardElement.classList.add('diamonds');
                if (this.suit === 'C') cardElement.classList.add('clubs');
                if (this.suit === 'S') cardElement.classList.add('spades');

                // Create card structure
                const cardTop = document.createElement('div');
                cardTop.className = 'card-top';
                cardTop.textContent = `${this.displayRank}${this.suitSymbol}`;
                
                const cardCenter = document.createElement('div');
                cardCenter.className = 'card-center';
                cardCenter.textContent = this.suitSymbol;
                
                const cardBottom = document.createElement('div');
                cardBottom.className = 'card-bottom';
                cardBottom.textContent = `${this.displayRank}${this.suitSymbol}`;
                
                cardElement.appendChild(cardTop);
                cardElement.appendChild(cardCenter);
                cardElement.appendChild(cardBottom);
                
                return cardElement;
            }
        }

        // Deck class to manage card collections
        class Deck {
            constructor() {
                this.cards = [];
                this.initializeDeck();
                this.shuffle();
            }

            // Create a standard 52-card deck
            initializeDeck() {
                const suits = ['H', 'D', 'C', 'S'];
                const ranks = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13'];
                
                for (const suit of suits) {
                    for (const rank of ranks) {
                        this.cards.push(new Card(suit, rank));
                    }
                }
            }

            // Fisher-Yates shuffle algorithm
            shuffle() {
                for (let i = this.cards.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]];
                }
            }

            // Draw a card from the deck
            drawCard() {
                if (this.cards.length === 0) return null;
                return this.cards.pop();
            }

            // Get the number of remaining cards
            get remainingCards() {
                return this.cards.length;
            }
        }

        // Set class to manage card sets
        class CardSet {
            constructor(cards = []) {
                this.cards = cards;
                this.type = this.determineSetType();
            }

            // Add a card to the set
            addCard(card) {
                this.cards.push(card);
                this.type = this.determineSetType();
            }

            // Remove a card from the set
            removeCard(cardId) {
                this.cards = this.cards.filter(card => card.id !== cardId);
                this.type = this.determineSetType();
            }

            // Determine if this is a valid set
            isValid() {
                return this.type !== 'invalid';
            }

            // Get the combined value of all cards in the set
            getTotalValue() {
                return this.cards.reduce((sum, card) => sum + card.value, 0);
            }

            // Create a DOM element representing this set
            createSetElement() {
                const setElement = document.createElement('div');
                setElement.className = 'set';
                
                // Add a class if this is a valid set
                if (this.isValid()) {
                    setElement.classList.add('valid-set');
                }
                
                // Add all cards to the set element
                for (const card of this.cards) {
                    const cardElement = card.createSimpleCardElement();
                    setElement.appendChild(cardElement);
                }
                
                return setElement;
            }

            // Determine if this is a matching set or a run
            determineSetType() {
                if (this.cards.length < 3) return 'invalid';
                
                // Check if it's a matching set (same rank)
                const isMatchingSet = this.isMatchingSet();
                
                // Check if it's a run (consecutive cards of same suit)
                const isRun = this.isRun();
                
                if (isMatchingSet) return 'matching';
                if (isRun) return 'run';
                return 'invalid';
            }

            // Check if all cards have the same rank
            isMatchingSet() {
                if (this.cards.length < 3) return false;
                
                const firstRank = this.cards[0].rank;
                return this.cards.every(card => card.rank === firstRank);
            }

            // Check if the cards form a consecutive sequence of the same suit
            isRun() {
                if (this.cards.length < 3) return false;
                
                // All cards must be of the same suit
                const firstSuit = this.cards[0].suit;
                if (!this.cards.every(card => card.suit === firstSuit)) return false;
                
                // Sort cards by rank (handling Aces specially)
                const sortedCards = [...this.cards].sort((a, b) => {
                    // Special case for Ace
                    if (a.rank === '1' && b.rank === '1') return 0;
                    if (a.rank === '1') return -1;
                    if (b.rank === '1') return 1;
                    
                    return a.numericRank - b.numericRank;
                });
                
                // Check if they form a consecutive sequence
                for (let i = 0; i < sortedCards.length - 1; i++) {
                    const currentCard = sortedCards[i];
                    const nextCard = sortedCards[i + 1];
                    
                    // Handle the special case for Ace (1) and King (13)
                    if (currentCard.rank === '1' && nextCard.rank === '13') {
                        return false; // Ace and King are not consecutive
                    }
                    
                    // Handle Ace low (A, 2, 3)
                    if (currentCard.rank === '1' && nextCard.rank === '2') {
                        continue;
                    }
                    
                    // Handle Ace high (K, A)
                    if (currentCard.rank === '13' && nextCard.rank === '1') {
                        continue;
                    }
                    
                    // Normal case: check if cards are consecutive
                    if (currentCard.numericRank + 1 !== nextCard.numericRank) {
                        return false;
                    }
                }
                
                return true;
            }
        }

        // Player class
        class Player {
            constructor(isAI = false) {
                this.hand = [];
                this.sets = [];
                this.isAI = isAI;
                this.score = 0;
                this.cocottes = 0;
                
                // Column-specific score tracking
                this.column1Points = 0;
                this.column2Points = 0;
                this.column3Points = 0;
                this.column1Cocottes = 0;
                this.column2Cocottes = 0;
                this.column3Cocottes = 0;
            }

            // Add a card to the player's hand
            addCard(card) {
                this.hand.push(card);
            }

            // Remove a card from the player's hand
            removeCard(cardId) {
                const index = this.hand.findIndex(card => card.id === cardId);
                if (index !== -1) {
                    const removedCard = this.hand.splice(index, 1)[0];
                    return removedCard;
                }
                return null;
            }

            // Get the total value of unmatched cards
            getUnmatchedCardsValue() {
                // Get all cards that are in sets
                const cardsInSets = this.sets.flatMap(set => set.cards);
                const cardsInSetsIds = cardsInSets.map(card => card.id);
                
                // Find unmatched cards
                const unmatchedCards = this.hand.filter(card => !cardsInSetsIds.includes(card.id));
                
                // Calculate total value
                return unmatchedCards.reduce((sum, card) => sum + card.value, 0);
            }

            // Get the unmatched cards
            getUnmatchedCards() {
                // Get all cards that are in sets
                const cardsInSets = this.sets.flatMap(set => set.cards);
                const cardsInSetsIds = cardsInSets.map(card => card.id);
                
                // Find unmatched cards
                return this.hand.filter(card => !cardsInSetsIds.includes(card.id));
            }

            // Check if player has a valid Gin
            hasGin() {
                const unmatchedCards = this.getUnmatchedCards();
                return unmatchedCards.length === 1 && this.sets.every(set => set.isValid());
            }

            // Check if player has a valid Grand Gin
            hasGrandGin() {
                const unmatchedCards = this.getUnmatchedCards();
                return unmatchedCards.length === 0 && this.sets.every(set => set.isValid());
            }

            // Check if player can Go Down
            canGoDown(descentValue) {
                const unmatchedCards = this.getUnmatchedCards();
                
                // No unmatched cards? Then it's Grand Gin, not Go Down
                if (unmatchedCards.length === 0) return false;
                
                // One unmatched card? Then it's Gin, not Go Down
                if (unmatchedCards.length === 1) return false;
                
                // Check if unmatched cards meet the descent value criteria
                if (descentValue === 'A') return false; // Can't Go Down during Gin Obligatoire
                
                // Get numeric value of descent card
                const numericDescentValue = descentValue === 'A' ? 15 :
                                           ['J', 'Q', 'K'].includes(descentValue) ? 10 :
                                           parseInt(descentValue);
                
                // We need at least 2 cards (1 for Go Down, 1 for discard)
                if (unmatchedCards.length < 2) return false;
                
                // Check if any subset of unmatched cards (except one for discard) has sum <= descentValue
                return this.hasSubsetSumLessOrEqual(unmatchedCards, numericDescentValue);
            }

            // Check if there's any subset of cards whose sum is <= maxValue
            hasSubsetSumLessOrEqual(cards, maxValue) {
                // Start with just one card
                for (const card of cards) {
                    if (card.value <= maxValue) return true;
                }
                
                // Try combinations of multiple cards
                const generateCombinations = (start, currentSum, count) => {
                    if (currentSum <= maxValue && count > 0) return true;
                    
                    for (let i = start; i < cards.length; i++) {
                        if (currentSum + cards[i].value <= maxValue) {
                            if (generateCombinations(i + 1, currentSum + cards[i].value, count + 1)) {
                                return true;
                            }
                        }
                    }
                    
                    return false;
                };
                
                return generateCombinations(0, 0, 0);
            }

            // AI strategy for deciding which card to discard
            aiChooseCardToDiscard() {
                // Sort cards by value (highest first)
                const sortedByValue = [...this.hand].sort((a, b) => b.value - a.value);
                
                // Prioritize discarding high-value cards not part of any potential set
                for (const card of sortedByValue) {
                    if (!this.isPartOfPotentialSet(card)) {
                        return card;
                    }
                }
                
                // If all cards are part of potential sets, discard the highest value card
                return sortedByValue[0];
            }

            // Check if a card could be part of a potential set
            isPartOfPotentialSet(targetCard) {
                const sameSuit = this.hand.filter(card => 
                    card.id !== targetCard.id && card.suit === targetCard.suit
                );
                
                const sameRank = this.hand.filter(card => 
                    card.id !== targetCard.id && card.rank === targetCard.rank
                );
                
                // Check for potential matching set (need at least 2 cards of same rank)
                if (sameRank.length >= 2) return true;
                
                // Check for potential runs in same suit
                const targetRank = parseInt(targetCard.rank);
                const adjacentRanks = sameSuit.filter(card => {
                    const cardRank = parseInt(card.rank);
                    return Math.abs(cardRank - targetRank) <= 2;
                });
                
                if (adjacentRanks.length >= 2) return true;
                
                return false;
            }

            // AI strategy to choose which pile to draw from
            aiChooseDrawPile(discardCard) {
                // If the discard pile is empty, draw from stock
                if (!discardCard) return 'stock';
                
                // Check if the discard card could be useful
                if (this.isCardUseful(discardCard)) {
                    return 'discard';
                }
                
                return 'stock';
            }

            // Determine if a card would be useful for the AI's hand
            isCardUseful(targetCard) {
                // Check if the card would complete or extend a set
                const sameRank = this.hand.filter(card => card.rank === targetCard.rank);
                
                // If we already have 2 or more of the same rank, it's useful for a matching set
                if (sameRank.length >= 2) return true;
                
                // Check for potential runs
                const sameSuit = this.hand.filter(card => card.suit === targetCard.suit);
                
                // If we have adjacent ranks in the same suit
                for (const card of sameSuit) {
                    const cardRank = parseInt(card.rank);
                    const targetRank = parseInt(targetCard.rank);
                    
                    if (Math.abs(cardRank - targetRank) === 1) {
                        // Check if the other adjacent rank is also in hand
                        const otherAdjacentRank = targetRank + (targetRank - cardRank);
                        
                        if (sameSuit.some(c => parseInt(c.rank) === otherAdjacentRank)) {
                            return true;
                        }
                    }
                }
                
                // If the card is an Ace, give it special consideration
                if (targetCard.rank === '1') {
                    // Check if we have King or 2 of the same suit
                    if (sameSuit.some(c => c.rank === '13' || c.rank === '2')) {
                        return true;
                    }
                }
                
                return false;
            }

            // AI strategy for finding sets
            aiFormSets() {
                this.sets = [];
                
                // First, find all possible matching sets (3+ cards of same rank)
                const rankGroups = {};
                
                for (const card of this.hand) {
                    if (!rankGroups[card.rank]) {
                        rankGroups[card.rank] = [];
                    }
                    rankGroups[card.rank].push(card);
                }
                
                // Form matching sets with 3+ cards
                for (const rank in rankGroups) {
                    if (rankGroups[rank].length >= 3) {
                        this.sets.push(new CardSet(rankGroups[rank]));
                    }
                }
                
                // Now, find all possible runs (consecutive cards of same suit)
                const suitGroups = {};
                
                // Group cards by suit
                for (const card of this.hand) {
                    if (!this.isCardInSet(card)) {  // Skip cards already in sets
                        if (!suitGroups[card.suit]) {
                            suitGroups[card.suit] = [];
                        }
                        suitGroups[card.suit].push(card);
                    }
                }
                
                // For each suit, find runs
                for (const suit in suitGroups) {
                    if (suitGroups[suit].length >= 3) {
                        const potentialRuns = this.findRuns(suitGroups[suit]);
                        
                        for (const run of potentialRuns) {
                            if (run.length >= 3) {
                                this.sets.push(new CardSet(run));
                            }
                        }
                    }
                }
                
                return this.sets;
            }

            // Check if a card is already included in a set
            isCardInSet(targetCard) {
                return this.sets.some(set => 
                    set.cards.some(card => card.id === targetCard.id)
                );
            }

            // Find all possible runs in a group of cards of the same suit
            findRuns(cards) {
                if (cards.length < 3) return [];
                
                // Sort cards by rank
                const sortedCards = [...cards].sort((a, b) => a.numericRank - b.numericRank);
                
                const runs = [];
                let currentRun = [sortedCards[0]];
                
                // Find consecutive sequences
                for (let i = 1; i < sortedCards.length; i++) {
                    const prevCard = sortedCards[i - 1];
                    const currentCard = sortedCards[i];
                    
                    // Check if cards are consecutive
                    if (currentCard.numericRank === prevCard.numericRank + 1) {
                        currentRun.push(currentCard);
                    } else {
                        if (currentRun.length >= 3) {
                            runs.push([...currentRun]);
                        }
                        currentRun = [currentCard];
                    }
                }
                
                // Don't forget the last run
                if (currentRun.length >= 3) {
                    runs.push(currentRun);
                }
                
                // Special case: Ace can be low or high
                // Check for runs with Ace as low (A,2,3)
                const aceCards = cards.filter(card => card.rank === '1');
                const twoCards = cards.filter(card => card.rank === '2');
                const threeCards = cards.filter(card => card.rank === '3');
                
                if (aceCards.length > 0 && twoCards.length > 0 && threeCards.length > 0) {
                    runs.push([aceCards[0], twoCards[0], threeCards[0]]);
                }
                
                // Check for runs with Ace as high (Q,K,A)
                const queenCards = cards.filter(card => card.rank === '12');
                const kingCards = cards.filter(card => card.rank === '13');
                
                if (aceCards.length > 0 && kingCards.length > 0 && queenCards.length > 0) {
                    runs.push([queenCards[0], kingCards[0], aceCards[0]]);
                }
                
                return runs;
            }
        }

        // Function to update the scorecard in the game
        function updateScoreCard() {
            // For demonstration, adding crossed-out scores like in the mockup for Player 2, Column 1
            const p2c1Points = document.getElementById('p2c1-points');
            p2c1Points.innerHTML = '48<br><span class="score-crossed-out">100</span><br><span class="score-current">209</span>';
            
            const p2c1Cocottes = document.getElementById('p2c1-cocottes');
            p2c1Cocottes.innerHTML = '3<br><span class="score-crossed-out">12</span><br><span class="score-current">13</span>';
            
            // Update Player 2, Column 2
            document.getElementById('p2c2-points').textContent = '161';
            document.getElementById('p2c2-cocottes').textContent = '10';
            
            // Update Player 2, Column 3
            document.getElementById('p2c3-points').textContent = '19';
            document.getElementById('p2c3-cocottes').textContent = '1';
            
            // Update Player 1, Column 1
            document.getElementById('p1c1-points').textContent = '25';
            document.getElementById('p1c1-cocottes').textContent = '3';
        }

        // Game class to manage the overall game state
        class MandelGinGame {
            constructor() {
                this.player = new Player(false);
                this.opponent = new Player(true);
                this.mainDeck = null;
                this.descentDeck = null;
                this.discardPile = [];
                this.currentPlayer = null;
                this.isGameOver = false;
                this.isHandOver = false;
                this.isPlayerTurn = false;
                this.descentCard = null;
                this.isDoubleScoring = false;
                this.isGinObligatoire = false;
                this.selectedCards = [];
                this.playerDrew = false;
                this.goDownCards = null;
                this.enableDebug = true; // Set to false to disable debug logging
                
                // Dealer logic
                this.isDealer = false;  // Is the player the dealer?
                this.isFirstHand = true;  // Is this the first hand?
                this.lastHandWinner = null;  // Who won the last hand?
                
                // Drag and drop functionality
                this.draggedCardId = null;
                this.isDragging = false;
                
                // UI elements
                this.playerHandElement = document.getElementById('playerHand');
                this.opponentHandElement = document.getElementById('opponentHand');
                this.deckElement = document.getElementById('deck');
                this.deckCountElement = document.getElementById('deckCount');
                this.discardElement = document.getElementById('discard');
                this.discardCountElement = document.getElementById('discardCount');
                this.descentCardElement = document.getElementById('descentCard');
                this.descentValueElement = document.getElementById('descentValue');
                this.gameStatusElement = document.getElementById('gameStatus');
                this.playerPointsElement = document.getElementById('p1c1-points'); // Updated for scorecard
                this.playerCocottesElement = document.getElementById('p1c1-cocottes'); // Updated for scorecard
                this.opponentPointsElement = document.getElementById('p2c1-points'); // Updated for scorecard
                this.opponentCocottesElement = document.getElementById('p2c1-cocottes'); // Updated for scorecard
                this.actionButtonsElement = document.getElementById('actionButtons');
                this.goDownButtonElement = document.getElementById('goDownButton');
                this.ginButtonElement = document.getElementById('ginButton');
                this.grandGinButtonElement = document.getElementById('grandGinButton');
                this.setsManagerElement = document.getElementById('setsManager');
                this.availableCardsElement = document.getElementById('availableCards');
                this.currentSetsElement = document.getElementById('currentSets');
                this.createSetButtonElement = document.getElementById('createSetButton');
                this.clearSetButtonElement = document.getElementById('clearSetButton');
                this.playerSetsElement = document.getElementById('playerSets');
                this.opponentSetsElement = document.getElementById('opponentSets');
                this.playerUnmatchedElement = document.getElementById('playerUnmatched');
                
                // Event listeners
                this.setupEventListeners();
                
                // Setup initial game
                this.setupNewGame();
            }

            // Debug logging helper
            debug(...args) {
                if (this.enableDebug) {
                    console.log('[MandelGin Debug]', ...args);
                }
            }

            // Set up all event listeners
            setupEventListeners() {
                document.getElementById('newGameButton').addEventListener('click', () => this.setupNewGame());
                document.getElementById('newGameMenuButton').addEventListener('click', () => {
                    document.getElementById('menuDialog').style.display = 'none';
                    this.setupNewGame();
                });
                
                this.deckElement.addEventListener('click', () => this.onDeckClick());
                this.discardElement.addEventListener('click', () => this.onDiscardClick());
                
                this.goDownButtonElement.addEventListener('click', () => this.onGoDownClick());
                this.ginButtonElement.addEventListener('click', () => this.onGinClick());
                this.grandGinButtonElement.addEventListener('click', () => this.onGrandGinClick());
                
                this.createSetButtonElement.addEventListener('click', () => this.onCreateSetClick());
                this.clearSetButtonElement.addEventListener('click', () => this.clearSelectedCards());
                
                document.getElementById('confirmGoDownButton').addEventListener('click', () => this.confirmGoDown());
                document.getElementById('cancelGoDownButton').addEventListener('click', () => {
                    document.getElementById('goDownDialog').style.display = 'none';
                });
                
                document.getElementById('rulesButton').addEventListener('click', () => {
                    document.getElementById('rulesDialog').style.display = 'flex';
                });
                
                document.getElementById('closeRulesButton').addEventListener('click', () => {
                    document.getElementById('rulesDialog').style.display = 'none';
                });
                
                document.getElementById('menuButton').addEventListener('click', () => {
                    updateScoreCard(); // Update scorecard before showing menu
                    document.getElementById('menuDialog').style.display = 'flex';
                });
                
                document.getElementById('closeMenuButton').addEventListener('click', () => {
                    document.getElementById('menuDialog').style.display = 'none';
                });
                
                document.getElementById('rulesMenuButton').addEventListener('click', () => {
                    document.getElementById('menuDialog').style.display = 'none';
                    document.getElementById('rulesDialog').style.display = 'flex';
                });
                
                document.getElementById('nextHandButton').addEventListener('click', () => {
                    document.getElementById('gameEndDialog').style.display = 'none';
                    this.setupNewHand();
                });
            }
